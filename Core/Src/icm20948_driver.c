/*
 * icm20948_driver.c
 *
 * Created on: May 9, 2025
 * Author: User (Generated by AI)
 * Description: ICM-20948 9軸感測器驅動程式實作
 */

#include "icm20948_driver.h"//SPI MODE 3
#include "main.h" // 確保 SPI_HandleTypeDef 和 GPIO 定義被引入 (包含 ICM20948_CS_Pin 和 ICM20948_CS_GPIO_Port)
#include <string.h> // 若有使用到 memcpy 等函式

// SPI 通訊逾時時間 (可依實際情況調整)
#define SPI_TIMEOUT 100 // ms

// --- 全域變數定義 (對應標頭檔中的 extern 宣告) ---
//SPI_HandleTypeDef hspi1; // SPI 控制代碼，需在 main.c 中初始化並賦值

// 感測器原始數據
int16_t accel_raw[3];
int16_t gyro_raw[3];
int16_t mag_raw[3];

// 感測器轉換後數據
float accel_g[3];
float gyro_dps[3];
float mag_uT[3];

// 當前選擇的加速計和陀螺儀靈敏度 (預設值，可在初始化時修改)
static float current_accel_sensitivity = ACCEL_SENSITIVITY_2G;
static float current_gyro_sensitivity = GYRO_SENSITIVITY_250DPS;


/**
 * @brief 選取 ICM-20948 的 SPI 片選 (CS) 引腳 (設為低電位)。
 * @note  使用 main.h 中定義的 ICM20948_CS_GPIO_Port 和 ICM20948_CS_Pin。
 */
void ICM20948_CS_Select(void) {
    HAL_GPIO_WritePin(ICM20948_CS_GPIO_Port, ICM20948_CS_Pin, GPIO_PIN_RESET);
    // Datasheet 建議 CS 低電位到 SCLK 上升沿至少 20ns (tCSS)
    // HAL_Delay(1) 太長，但對於基本功能通常可行。若有高速通訊問題可考慮更精確的延遲或移除。
    // 若 SPI 時脈很慢，此延遲可能不需要或可以縮短。
    // 為了確保穩定性，保留一個非常短的延遲或直接移除，取決於 SPI 時脈和硬體特性。
    // 如果 SPI 時脈在 MHz 等級，CPU 指令本身可能就足夠。
    // 這裡保留 HAL_Delay(1) 作為一個保守的選擇，但可以根據實際測試進行優化。
    for (volatile int i = 0; i < 10; i++); // 非常短的延遲替代 HAL_Delay(1)
}

/**
 * @brief 取消選取 ICM-20948 的 SPI 片選 (CS) 引腳 (設為高電位)。
 * @note  使用 main.h 中定義的 ICM20948_CS_GPIO_Port 和 ICM20948_CS_Pin。
 */
void ICM20948_CS_Deselect(void) {
    HAL_GPIO_WritePin(ICM20948_CS_GPIO_Port, ICM20948_CS_Pin, GPIO_PIN_SET);
    // Datasheet 建議 SCLK 下降沿到 CS 高電位至少 20ns (tCSH)
    // 同上，HAL_Delay(1) 可能過長。
    for (volatile int i = 0; i < 10; i++); // 非常短的延遲
}

/**
 * @brief 透過 SPI 寫入單一位元組數據至 ICM-20948 指定暫存器。
 * @param reg_addr: 目標暫存器位址 (7位元，最高位元為0代表寫入)。
 * @param data:     要寫入的數據。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef ICM20948_WriteByte(uint8_t reg_addr, uint8_t data) {
    uint8_t tx_buffer[2];
    HAL_StatusTypeDef status;

    tx_buffer[0] = reg_addr & 0x7F; // 寫入操作，MSB 為 0
    tx_buffer[1] = data;

    ICM20948_CS_Select();
    status = HAL_SPI_Transmit(&hspi1, tx_buffer, 2, SPI_TIMEOUT);
    ICM20948_CS_Deselect();

    if (status != HAL_OK) {
        // 可在此處加入錯誤處理，例如記錄錯誤或重試
    }
    return status;
}

/**
 * @brief 透過 SPI 從 ICM-20948 指定暫存器讀取單一位元組數據。
 * @param reg_addr: 目標暫存器位址 (7位元，最高位元為1代表讀取)。
 * @param pData:    指向儲存讀取數據的緩衝區指標。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef ICM20948_ReadByte(uint8_t reg_addr, uint8_t *pData) {
    uint8_t tx_byte;
    HAL_StatusTypeDef status;

    tx_byte = reg_addr | 0x80; // 讀取操作，MSB 為 1

    ICM20948_CS_Select();
    status = HAL_SPI_Transmit(&hspi1, &tx_byte, 1, SPI_TIMEOUT); // 發送要讀取的暫存器位址
    if (status == HAL_OK) {
        status = HAL_SPI_Receive(&hspi1, pData, 1, SPI_TIMEOUT); // 接收數據
    }
    ICM20948_CS_Deselect();

    if (status != HAL_OK) {
        // 可在此處加入錯誤處理
    }
    return status;
}

/**
 * @brief 透過 SPI 從 ICM-20948 指定起始暫存器連續讀取多個位元組數據。
 * @param reg_addr: 起始目標暫存器位址 (7位元，最高位元為1代表讀取)。
 * @param pData:    指向儲存讀取數據的緩衝區指標。
 * @param count:    要讀取的位元組數量。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef ICM20948_ReadBytes(uint8_t reg_addr, uint8_t *pData, uint16_t count) {
    uint8_t tx_byte;
    HAL_StatusTypeDef status;

    tx_byte = reg_addr | 0x80; // 讀取操作，MSB 為 1

    ICM20948_CS_Select();
    status = HAL_SPI_Transmit(&hspi1, &tx_byte, 1, SPI_TIMEOUT); // 發送起始暫存器位址
    if (status == HAL_OK) {
        status = HAL_SPI_Receive(&hspi1, pData, count, SPI_TIMEOUT); // 連續接收多個位元組
    }
    ICM20948_CS_Deselect();

    if (status != HAL_OK) {
        // 可在此處加入錯誤處理
    }
    return status;
}

/**
 * @brief 選擇 ICM-20948 的使用者庫 (User Bank)。
 * @param bank: 要選擇的庫編號 (0, 1, 2, 或 3)。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 * @note  REG_BANK_SEL 暫存器在所有庫中皆可存取。
 * 位元 [5:4] 用於選擇庫: 00 for UB0, 01 for UB1, 10 for UB2, 11 for UB3.
 */
HAL_StatusTypeDef ICM20948_SelectUserBank(uint8_t bank) {
    if (bank > 3) {
        return HAL_ERROR; // 無效的庫編號
    }
    // REG_BANK_SEL (0x7F) 的位元 [5:4] (USER_BANK) 控制庫選擇
    // bank 0 -> 0x00
    // bank 1 -> 0x10
    // bank 2 -> 0x20
    // bank 3 -> 0x30
    return ICM20948_WriteByte(ICM20948_REG_BANK_SEL, (bank << 4));
}

/**
 * @brief 透過 ICM-20948 的 I2C 主機介面，寫入單一位元組數據至 AK09916 磁力計指定暫存器。
 * @param reg_addr: AK09916 的目標暫存器位址。
 * @param data:     要寫入的數據。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef AK09916_WriteByteViaICM(uint8_t reg_addr, uint8_t data) {
    HAL_StatusTypeDef status;
    uint8_t current_bank_sel_val;
    uint8_t target_bank = 3; // I2C 主機控制相關暫存器在庫 3

    // 讀取當前庫選擇，以便操作完成後恢復
    // REG_BANK_SEL 本身在所有庫都可訪問，所以不需要先切換到特定庫來讀它
    // 但為了嚴謹，通常會先切換到一個已知庫 (如庫0) 來進行這種操作
    // status = ICM20948_ReadByte(ICM20948_REG_BANK_SEL, &current_bank_sel_val);
    // if (status != HAL_OK) return status;
    // current_bank_sel_val = (current_bank_sel_val >> 4) & 0x03; // 提取庫號

    // 1. 切換到使用者庫 3
    status = ICM20948_SelectUserBank(target_bank);
    if (status != HAL_OK) return status;

    // 2. 設定從裝置位址 (AK09916_I2C_ADDR，不含 R/W 位元，表示寫入)
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR); //  R/W bit is 0 for write
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(0); // 嘗試恢復到庫0
        return status;
    }

    // 3. 設定要寫入的 AK09916 內部暫存器位址
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_REG, reg_addr);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(0);
        return status;
    }

    // 4. 設定要寫入的數據
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_DO, data);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(0);
        return status;
    }

    // 5. 致能 I2C 從裝置 0，並設定為寫入一個位元組，觸發傳輸
    //   I2C_SLV0_EN (bit 7) = 1 (致能)
    //   I2C_SLV0_LENG (bits 3:0) = 1 (傳輸 1 個位元組)
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x01);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(0);
        return status;
    }

    // 6. 等待 I2C 傳輸完成。
    //    理想情況下，應該檢查 I2C_MST_STATUS 暫存器中的 I2C_SLV0_NACK 或 I2C_IF_DONE 位元。
    //    為簡化，這裡使用固定延遲。在實際應用中，需要更可靠的同步機制。
    //    ICM20948 datasheet 7.6節: "The I2C Master interface issues a STOP condition specific to the transaction length."
    //    "The I2C Master interface will stretch the main processor’s clock when an I2C transaction is in progress." (if I2C_MST_P_NSR=1 in I2C_MST_CTRL)
    //    這裡假設 I2C_MST_P_NSR=0 (預設)，所以需要軟體延遲或狀態檢查。
    HAL_Delay(5); // 稍微增加延遲以確保傳輸完成 (這個延遲可能需要調整，取決於 I2C 速度和目標設備)

    // 7. (可選) 檢查傳輸狀態，例如 I2C_MST_STATUS 中的 I2C_SLV0_NACK 位元
    //    status = ICM20948_SelectUserBank(0); // 為了讀 I2C_MST_STATUS，它在 User Bank 0
    //    if (status != HAL_OK) return status;
    //    uint8_t i2c_mst_status_val;
    //    status = ICM20948_ReadByte(0x17, &i2c_mst_status_val); // I2C_MST_STATUS (UB0)
    //    if (status != HAL_OK) return status;
    //    if (i2c_mst_status_val & 0x01) { /* I2C_SLV0_NACK */ return HAL_ERROR; }

    // 操作完成後，建議切換回常用的庫，例如庫 0
    return ICM20948_SelectUserBank(0);
}

/**
 * @brief 透過 ICM-20948 的 I2C 主機介面，從 AK09916 磁力計指定暫存器讀取單一位元組數據。
 * @param reg_addr: AK09916 的目標暫存器位址。
 * @param pData:    指向儲存讀取數據的緩衝區指標。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef AK09916_ReadByteViaICM(uint8_t reg_addr, uint8_t *pData) {
    HAL_StatusTypeDef status;
    uint8_t temp_data;
    uint8_t target_bank = 3; // I2C 主機控制相關暫存器在庫 3
    uint8_t data_read_bank = 0; // 外部感測器數據在庫 0

    // 1. 切換到使用者庫 3，設定 I2C 從裝置相關暫存器
    status = ICM20948_SelectUserBank(target_bank);
    if (status != HAL_OK) return status;

    // 2. 設定從裝置位址 (AK09916_I2C_ADDR | 0x80，設定 R/W 位元為讀取)
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(data_read_bank); // 嘗試恢復
        return status;
    }

    // 3. 設定要讀取的 AK09916 內部暫存器位址
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_REG, reg_addr);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(data_read_bank);
        return status;
    }

    // 4. 致能 I2C 從裝置 0，設定為讀取一個位元組，並觸發讀取
    //   I2C_SLV0_EN (bit 7) = 1 (致能)
    //   I2C_SLV0_LENG (bits 3:0) = 1 (傳輸 1 個位元組)
    //   I2C_SLV0_REG_DIS (bit 5) = 0 (寫入 reg_addr)
    //   I2C_SLV0_BYTE_SW (bit 6) = 0 (預設)
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x01);
    if (status != HAL_OK) {
        ICM20948_SelectUserBank(data_read_bank);
        return status;
    }

    // 5. 等待 I2C 傳輸完成並數據就緒
    HAL_Delay(5); // 這個延遲可能需要調整，最好是檢查狀態位元

    // 6. 切換回使用者庫 0 以讀取外部感測器數據
    status = ICM20948_SelectUserBank(data_read_bank);
    if (status != HAL_OK) return status;

    // 7. 從 EXT_SLV_SENS_DATA_00 讀取數據
    //    ICM-20948 會自動將從 SLV0 讀到的數據放入 EXT_SLV_SENS_DATA_00 開始的暫存器中
    status = ICM20948_ReadByte(ICM20948_EXT_SLV_SENS_DATA_00, &temp_data);
    if (status == HAL_OK) {
        *pData = temp_data;
    }
    return status;
}

/**
 * @brief 初始化 ICM-20948 感測器 (包括加速計、陀螺儀和磁力計)。
 * @return HAL_StatusTypeDef: 初始化成功則返回 HAL_OK，否則返回 HAL_ERROR。
 */
HAL_StatusTypeDef ICM20948_Init(void) {
    HAL_StatusTypeDef status = HAL_OK;
    uint8_t who_am_i_val = 0;
    uint8_t ak09916_wia2_val = 0;

    // --- 0. 確保 SPI CS 引腳初始為高電位 ---
    ICM20948_CS_Deselect(); // 使用更新後的 CS 控制函式
    HAL_Delay(10); // 等待感測器上電穩定

    // --- 1. 選擇使用者庫 0 ---
    status = ICM20948_SelectUserBank(0);
    if (status != HAL_OK) return HAL_ERROR; // 如果切換庫失敗，則初始化失敗

    // --- 2. 檢查 WHO_AM_I 暫存器 ---
    status = ICM20948_ReadByte(ICM20948_WHO_AM_I, &who_am_i_val);
    if (status != HAL_OK || who_am_i_val != 0xEA) { // 0xEA 是 ICM-20948 的預期值
        // 可以嘗試多次讀取 WHO_AM_I，因為有時第一次通訊可能不穩定
        HAL_Delay(1);
        // 嘗試多次讀取@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        for (int i = 0; i < 10; i++) {
            status = ICM20948_ReadByte(ICM20948_WHO_AM_I, &who_am_i_val);
            if (status == HAL_OK) {
                printf("WHO_AM_I: 0x%02X (Attempt %d)\r\n", who_am_i_val, i + 1);
            } else {
                printf("Read WHO_AM_I FAILED, Status: %d (Attempt %d)\r\n", status, i + 1);
            }
            HAL_Delay(50);
        }
        // 嘗試多次讀取@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        status = ICM20948_ReadByte(ICM20948_WHO_AM_I, &who_am_i_val);
        if (status != HAL_OK || who_am_i_val != 0xEA) {
             return HAL_ERROR; // 裝置識別失敗
        }
    }

    // --- 3. 重設並喚醒裝置 ---
    // 寫入 0x80 到 PWR_MGMT_1 (DEVICE_RESET = 1)
    status = ICM20948_WriteByte(ICM20948_PWR_MGMT_1, 0x80);
    if (status != HAL_OK) return HAL_ERROR;
    HAL_Delay(100); // 等待重設完成 (Datasheet 建議 100ms)

    // 從睡眠模式喚醒，並選擇時脈源
    // 寫入 0x01 到 PWR_MGMT_1 (CLKSEL = 1，選擇最佳可用時脈源，通常是內部20MHz振盪器, 自動選擇)
    // SLEEP = 0 (正常模式), TEMP_DIS = 0 (溫度感測器致能)
    status = ICM20948_WriteByte(ICM20948_PWR_MGMT_1, 0x01);
    if (status != HAL_OK) return HAL_ERROR;
    HAL_Delay(50); // 等待時脈穩定

    // --- 4. 配置加速計和陀螺儀 ---
    // 切換到使用者庫 2
    status = ICM20948_SelectUserBank(2);
    if (status != HAL_OK) return HAL_ERROR;

    // 加速計配置 (ACCEL_CONFIG)
    // ACCEL_FS_SEL: 00 = ±2g, 01 = ±4g, 10 = ±8g, 11 = ±16g (bits 2:1)
    // ACCEL_FCHOICE: 0 = 致能 DLPF, 1 = 旁路 DLPF (bit 0)
    // ACCEL_DLPFCFG: 加速計數位低通濾波器配置 (bits 5:3)
    // 這裡設定為 ±2g, DLPF 致能 (ACCEL_FCHOICE=0), DLPFCFG = 1 (約 246Hz 頻寬, 3dB BW; ODR 1.125kHz)
    // ACCEL_CONFIG = (DLPFCFG << 3) | (ACCEL_FS_SEL << 1) | ACCEL_FCHOICE
    //              = (001 << 3)   | (00 << 1)        | 0
    //              = 0x08
    status = ICM20948_WriteByte(ICM20948_ACCEL_CONFIG, (0x01 << 3) | (0x00 << 1) | 0x00);
    if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }
    current_accel_sensitivity = ACCEL_SENSITIVITY_2G; // 更新當前靈敏度

    // 陀螺儀配置 (GYRO_CONFIG_1)
    // GYRO_FS_SEL: 00 = ±250dps, 01 = ±500dps, 10 = ±1000dps, 11 = ±2000dps (bits 2:1)
    // GYRO_FCHOICE: 0 = 致能 DLPF, 1 = 旁路 DLPF (bit 0)
    // GYRO_DLPFCFG: 陀螺儀數位低通濾波器配置 (bits 5:3)
    // 這裡設定為 ±250dps, DLPF 致能 (GYRO_FCHOICE=0), DLPFCFG = 1 (約 196.6Hz 頻寬, 3dB BW; ODR 1.125kHz)
    // GYRO_CONFIG_1 = (DLPFCFG << 3) | (GYRO_FS_SEL << 1) | GYRO_FCHOICE
    //               = (001 << 3)   | (00 << 1)       | 0
    //               = 0x08
    status = ICM20948_WriteByte(ICM20948_GYRO_CONFIG_1, (0x01 << 3) | (0x00 << 1) | 0x00);
    if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }
    current_gyro_sensitivity = GYRO_SENSITIVITY_250DPS; // 更新當前靈敏度

    // 設定取樣率分頻 (可選，預設為0，即最快取樣率 1.125kHz / (1+SMPLRT_DIV) )
    // status = ICM20948_WriteByte(ICM20948_GYRO_SMPLRT_DIV, 0x00); // 陀螺儀 ODR = 1.125kHz / (1 + 0)
    // if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }
    // status = ICM20948_WriteByte(ICM20948_ACCEL_SMPLRT_DIV_2, 0x00); // 加速計 ODR 低位元組
    // if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }
    // status = ICM20948_WriteByte(ICM20948_ACCEL_SMPLRT_DIV_1, 0x00); // 加速計 ODR 高位元組
    // if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }

    // 切換回使用者庫 0
    status = ICM20948_SelectUserBank(0);
    if (status != HAL_OK) return HAL_ERROR;

    // --- 5. 配置 I2C 主機介面以與 AK09916 通訊 ---
    // 致能 I2C 主機模式 (USER_CTRL 的 I2C_MST_EN 位元 (bit 5))
    uint8_t user_ctrl_val;
    status = ICM20948_ReadByte(ICM20948_USER_CTRL, &user_ctrl_val);
    if (status != HAL_OK) return HAL_ERROR;
    user_ctrl_val |= (1 << 5); // 設定 I2C_MST_EN = 1
    // user_ctrl_val &= ~(1 << 6); // 確保 I2C_IF_DIS = 0, 使能SPI和I2C同時工作 (如果需要SPI訪問ICM本身)
    status = ICM20948_WriteByte(ICM20948_USER_CTRL, user_ctrl_val);
    if (status != HAL_OK) return HAL_ERROR;
    HAL_Delay(50); // 等待 I2C 主機介面穩定

    // 切換到使用者庫 3
    status = ICM20948_SelectUserBank(3);
    if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }

    // 設定 I2C 主機時脈頻率 (I2C_MST_CTRL 的 I2C_MST_CLK bits 3:0)
    // 例如，設定為 400kHz (datasheet 建議值 0x07 for 345.6 kHz to 400 kHz)
    // 0x0D for ~100kHz if needed for stability with AK09916
    status = ICM20948_WriteByte(ICM20948_I2C_MST_CTRL, 0x07);
    if (status != HAL_OK) { ICM20948_SelectUserBank(0); return HAL_ERROR; }
    HAL_Delay(50);

    // 切換回使用者庫 0
    status = ICM20948_SelectUserBank(0);
    if (status != HAL_OK) return HAL_ERROR;

    // --- 6. 初始化 AK09916 磁力計 ---
    // 檢查 AK09916 WIA2 (公司識別碼)
    status = AK09916_ReadByteViaICM(AK09916_WIA2, &ak09916_wia2_val);
    if (status != HAL_OK || ak09916_wia2_val != 0x09) { // 0x09 是 AK09916 的預期公司 ID (AKM)
        // 有時 WIA1 (0x00) 讀出來是 0x48 (Device ID)
        // uint8_t wia1_val;
        // AK09916_ReadByteViaICM(0x00, &wia1_val);
        // if (wia1_val != 0x48) return HAL_ERROR; // 備用檢查
        return HAL_ERROR; // AK09916 識別失敗
    }

    // 軟復位 AK09916 (CNTL3 的 SRST 位元 (bit 0) 設為 1)
    status = AK09916_WriteByteViaICM(AK09916_CNTL3, 0x01);
    if (status != HAL_OK) return HAL_ERROR;
    HAL_Delay(100); // 等待復位完成 (AK09916 datasheet: At least 1ms after SRST bit is set to “1”.)

    // 設定 AK09916 操作模式 (CNTL2)
    // MODE[4:0]:
    // 00000: Power-down
    // 00001: Single measurement mode
    // 00010: Continuous measurement mode 1 (10Hz)
    // 00100: Continuous measurement mode 2 (20Hz)
    // 00110: Continuous measurement mode 3 (50Hz)
    // 01000: Continuous measurement mode 4 (100Hz)
    // 這裡設定為連續量測模式 4 (100Hz) -> 0x08
    status = AK09916_WriteByteViaICM(AK09916_CNTL2, 0x08);
    if (status != HAL_OK) return HAL_ERROR;
    HAL_Delay(50); // 等待模式設定生效

    // --- 7. 配置中斷 (可選，若需要資料就緒中斷) ---
    // 切換到 User Bank 0
    // status = ICM20948_SelectUserBank(0);
    // if (status != HAL_OK) return HAL_ERROR;
    // status = ICM20948_WriteByte(ICM20948_INT_PIN_CFG, 0x30); // INT1 active high, push-pull, latch INT_ENABLE, clear on read status
    // if (status != HAL_OK) return HAL_ERROR;
    // status = ICM20948_WriteByte(ICM20948_INT_ENABLE_1, 0x01); // Enable Raw Data Ready interrupt (RAW_RDY_EN bit 0)
    // if (status != HAL_OK) return HAL_ERROR;

    return HAL_OK; // 初始化成功
}

/**
 * @brief 從 ICM-20948 讀取加速計和陀螺儀的原始數據。
 * @param pAccel: 指向儲存加速計原始數據的陣列 (int16_t[3])。
 * @param pGyro:  指向儲存陀螺儀原始數據的陣列 (int16_t[3])。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef ICM20948_ReadAccelGyroRaw(int16_t* pAccel, int16_t* pGyro) {
    uint8_t raw_data[12]; // 6 bytes for accel (X,Y,Z), 6 bytes for gyro (X,Y,Z)
    HAL_StatusTypeDef status;

    // 1. 確保在使用者庫 0 (感測器數據通常在庫 0)
    status = ICM20948_SelectUserBank(0); // 雖然大部分情況下已在庫0，但確保一下無妨
    if (status != HAL_OK) return status;

    // 2. 從 ACCEL_XOUT_H (0x2D) 開始連續讀取 12 個位元組的數據
    //    ACCEL_XOUT_H to GYRO_ZOUT_L
    status = ICM20948_ReadBytes(ICM20948_ACCEL_XOUT_H, raw_data, 12);
    if (status != HAL_OK) return status;

    // 3. 解析數據 (高位元組在前，大端模式 Big-Endian)
    // 加速計數據
    pAccel[0] = (int16_t)((raw_data[0] << 8) | raw_data[1]);  // Accel X
    pAccel[1] = (int16_t)((raw_data[2] << 8) | raw_data[3]);  // Accel Y
    pAccel[2] = (int16_t)((raw_data[4] << 8) | raw_data[5]);  // Accel Z
    // 陀螺儀數據
    pGyro[0] = (int16_t)((raw_data[6] << 8) | raw_data[7]);   // Gyro X
    pGyro[1] = (int16_t)((raw_data[8] << 8) | raw_data[9]);   // Gyro Y
    pGyro[2] = (int16_t)((raw_data[10] << 8) | raw_data[11]); // Gyro Z

    return HAL_OK;
}


/**
 * @brief 透過 ICM-20948 的 I2C 主機從 AK09916 讀取多個位元組的磁力計數據。
 * @param reg_addr: AK09916 的起始暫存器位址。
 * @param pBuffer:  指向儲存讀取數據的緩衝區。
 * @param count:    要讀取的位元組數量 (AK09916 通常一次讀取 8 bytes: HXL to ST2)。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef AK09916_ReadBytesViaICM(uint8_t reg_addr, uint8_t *pBuffer, uint8_t count) {
    HAL_StatusTypeDef status;
    uint8_t target_bank = 3;
    uint8_t data_read_bank = 0;

    if (count == 0 || count > 8) { // EXT_SLV_SENS_DATA 暫存器最多支援讀取連續的外部數據長度有限制 (SLV0 可讀取 SLV0_LENG 個 bytes)
                                  // ICM20948 EXT_SLV_SENS_DATA_xx 最多有 24 個 bytes (00-23) 給所有 4 個 slave
                                  // SLV0_LENG 最大值是 15 (0xF)
        return HAL_ERROR;
    }

    // 1. 切換到使用者庫 3
    status = ICM20948_SelectUserBank(target_bank);
    if (status != HAL_OK) return status;

    // 2. 設定從裝置位址為讀取模式
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80); // Add R/W bit for read
    if (status != HAL_OK) { ICM20948_SelectUserBank(data_read_bank); return status; }

    // 3. 設定要讀取的 AK09916 起始內部暫存器位址
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_REG, reg_addr);
    if (status != HAL_OK) { ICM20948_SelectUserBank(data_read_bank); return status; }

    // 4. 致能 I2C SLV0，設定讀取位元組數量，並觸發事務
    //    I2C_SLV0_EN (bit 7) = 1
    //    I2C_SLV0_LENG (bits 3:0) = count
    status = ICM20948_WriteByte(ICM20948_I2C_SLV0_CTRL, 0x80 | count);
    if (status != HAL_OK) { ICM20948_SelectUserBank(data_read_bank); return status; }

    // 等待 I2C 傳輸完成，這個延遲需要足夠長以完成 'count' 個位元組的讀取
    // 每個位元組大約需要 8/I2C_Clock_Freq + ACK/NACK 時間。
    // 若 I2C 400kHz, 1 byte 約 25us. 8 bytes ~ 200us.
    HAL_Delay(count + 2); // 粗略延遲，最好檢查 I2C_MST_STATUS 或使用中斷
                          // (count * 25us / 1000) + 1 ms 作為基本延遲

    // 5. 切換回使用者庫 0 以讀取外部感測器數據
    status = ICM20948_SelectUserBank(data_read_bank);
    if (status != HAL_OK) return status;

    // 6. 從 EXT_SLV_SENS_DATA_00 開始讀取數據
    status = ICM20948_ReadBytes(ICM20948_EXT_SLV_SENS_DATA_00, pBuffer, count);
    return status;
}


/**
 * @brief 從 ICM-20948 (透過其 I2C 主機從 AK09916) 讀取磁力計的原始數據。
 * @param pMag:   指向儲存磁力計原始數據的陣列 (int16_t[3])。
 * @return HAL_StatusTypeDef: HAL 操作狀態。
 */
HAL_StatusTypeDef ICM20948_ReadMagRaw(int16_t* pMag) {
    uint8_t mag_buffer[8]; // AK09916: HXL, HXH, HYL, HYH, HZL, HZH, RSV, ST2 (共 8 bytes 從 HXL 到 ST2)
                           // RSV (0x17) 是保留位元組
    HAL_StatusTypeDef status;
    uint8_t st1_val;

    // 1. 檢查 AK09916 是否有新數據 (DRDY 位元在 ST1 (0x10) 暫存器)
    status = AK09916_ReadByteViaICM(AK09916_ST1, &st1_val);
    if (status != HAL_OK) return status;

    if (!(st1_val & 0x01)) { // 檢查 DRDY (Data Ready) 位元 (bit 0)
        return HAL_BUSY; // 數據尚未就緒 (Not an error, just not ready)
    }

    // 2. 從 AK09916_HXL (0x11) 開始讀取 8 個位元組 (HXL to ST2)
    //    讀取 ST2 (0x18) 是為了讓 AK09916 準備下一次量測 (清除 DRDY 狀態並觸發下一次)
    status = AK09916_ReadBytesViaICM(AK09916_HXL, mag_buffer, 8);
    if (status != HAL_OK) return status;

    // 3. 解析數據 (低位元組在前，小端模式 Little-Endian for AK09916)
    pMag[0] = (int16_t)(((uint16_t)mag_buffer[1] << 8) | mag_buffer[0]); // Mag X (HXH, HXL)
    pMag[1] = (int16_t)(((uint16_t)mag_buffer[3] << 8) | mag_buffer[2]); // Mag Y (HYH, HYL)
    pMag[2] = (int16_t)(((uint16_t)mag_buffer[5] << 8) | mag_buffer[4]); // Mag Z (HZH, HZL)

    // mag_buffer[6] is RSV (Reserved)
    // mag_buffer[7] is ST2 (Status 2)
    // 檢查 ST2 暫存器中的 HOFL (Magnetic sensor overflow) 位元 (bit 3)
    // if (mag_buffer[7] & 0x08) { /* Overflow occurred */ }

    // 重要: 讀取 ST2 暫存器後，AK09916 會清除 DRDY (Data Ready) 狀態，
    // 並在下一個量測週期後再次設定 DRDY。

    return HAL_OK;
}

/**
 * @brief 將加速計原始數據轉換為 g (重力加速度)。
 * @param pAccelRaw: 指向加速計原始數據陣列 (int16_t[3])。
 * @param pAccelG:   指向儲存轉換後數據的陣列 (float[3])。
 */
void ICM20948_ConvertAccelRawToG(const int16_t* pAccelRaw, float* pAccelG) {
    pAccelG[0] = (float)pAccelRaw[0] / current_accel_sensitivity;
    pAccelG[1] = (float)pAccelRaw[1] / current_accel_sensitivity;
    pAccelG[2] = (float)pAccelRaw[2] / current_accel_sensitivity;
}

/**
 * @brief 將陀螺儀原始數據轉換為 dps (度/秒)。
 * @param pGyroRaw: 指向陀螺儀原始數據陣列 (int16_t[3])。
 * @param pGyroDPS: 指向儲存轉換後數據的陣列 (float[3])。
 */
void ICM20948_ConvertGyroRawToDPS(const int16_t* pGyroRaw, float* pGyroDPS) {
    pGyroDPS[0] = (float)pGyroRaw[0] / current_gyro_sensitivity;
    pGyroDPS[1] = (float)pGyroRaw[1] / current_gyro_sensitivity;
    pGyroDPS[2] = (float)pGyroRaw[2] / current_gyro_sensitivity;
}

/**
 * @brief 將磁力計原始數據轉換為 µT (微特斯拉)。
 * @param pMagRaw: 指向磁力計原始數據陣列 (int16_t[3])。
 * @param pMagUT:  指向儲存轉換後數據的陣列 (float[3])。
 */
void ICM20948_ConvertMagRawToUT(const int16_t* pMagRaw, float* pMagUT) {
    // AK09916 的靈敏度是固定的 0.15 µT/LSB
    pMagUT[0] = (float)pMagRaw[0] * MAG_SENSITIVITY_UT_LSB;
    pMagUT[1] = (float)pMagRaw[1] * MAG_SENSITIVITY_UT_LSB;
    pMagUT[2] = (float)pMagRaw[2] * MAG_SENSITIVITY_UT_LSB;
}
void ICM20948_Main(){
	// 讀取加速計和陀螺儀原始數據
		     if (ICM20948_ReadAccelGyroRaw(accel_raw, gyro_raw) == HAL_OK) {
		       // 將原始數據轉換為物理單位
		       ICM20948_ConvertAccelRawToG(accel_raw, accel_g);
		       ICM20948_ConvertGyroRawToDPS(gyro_raw, gyro_dps);

		       // 透過 UART 輸出 (或使用除錯器查看變數)
		       printf("Accel(g): X=%.2f, Y=%.2f, Z=%.2f | Gyro(dps): X=%.2f, Y=%.2f, Z=%.2f\r\n",
		              accel_g[0], accel_g[1], accel_g[2],
		               gyro_dps[0], gyro_dps[1], gyro_dps[2]);
	//	       printf("%s"); // 或 HAL_UART_Transmit(&huartx, (uint8_t*)uart_buf, strlen(uart_buf), HAL_MAX_DELAY);

		     } else {
		    	 //讀取 Accel/Gyro 數據失敗
		       printf("Failed to read Accel/Gyro data!\r\n");
		     }

		     // 讀取磁力計原始數據
		     HAL_StatusTypeDef mag_status = ICM20948_ReadMagRaw(mag_raw);
		     if (mag_status == HAL_OK) {
		       // 將原始數據轉換為物理單位
		       ICM20948_ConvertMagRawToUT(mag_raw, mag_uT);

		       printf("Mag(uT): X=%.2f, Y=%.2f, Z=%.2f\r\n",
		               mag_uT[0], mag_uT[1], mag_uT[2]);
	//	       printf("%s");

		     } else if (mag_status == HAL_BUSY) {
		       //printf("磁力計數據尚未就緒 (DRDY=0)\r\n");
		    	 printf("(HAL_BUSY DRDY=0)\r\n");
		       // 這是正常情況，因為磁力計更新速率可能較慢或與主迴圈不同步
		     }
		     else {
		    	 //讀取 Mag 數據失敗!
		       printf("Failed to read Mag !\r\n");
		     }

		     printf("----------------------------------------\r\n");
		     HAL_Delay(100); // 每秒讀取一次數據
}
